<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Flappy Andrea</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #333;
            overflow: hidden; /* Kein Scrollen */
            font-family: 'Arial Black', sans-serif;
            touch-action: manipulation;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        #overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.5);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            text-align: center;
            pointer-events: none; /* Klicks gehen durch aufs Canvas */
        }
        h1 {
            font-size: 40px;
            color: #ffeb3b;
            text-shadow: 3px 3px 0 #000;
            margin: 0 0 20px 0;
        }
        p {
            font-size: 20px;
            text-shadow: 1px 1px 0 #000;
            animation: blink 1s infinite;
        }
        @keyframes blink { 50% { opacity: 0.5; } }
    </style>
</head>
<body>

<div id="overlay">
    <h1 id="title">FLAPPY ANDREA</h1>
    <p id="subtitle">Tippen zum Fliegen!</p>
</div>

<canvas id="gameCanvas"></canvas>

<script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const overlay = document.getElementById("overlay");
    const title = document.getElementById("title");
    const subtitle = document.getElementById("subtitle");

    // --- BILD LADEN ---
    const img = new Image();
    img.src = 'andrea.jpeg';

    // --- AUDIO SYNTHESIZER (Keine Dateien nötig) ---
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    const audioCtx = new AudioContext();

    function playSound(type) {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        const now = audioCtx.currentTime;

        if (type === 'flap') {
            osc.frequency.setValueAtTime(400, now);
            osc.frequency.exponentialRampToValueAtTime(600, now + 0.1);
            gain.gain.setValueAtTime(0.3, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
            osc.start(now); osc.stop(now + 0.1);
        } else if (type === 'score') {
            osc.type = 'square';
            osc.frequency.setValueAtTime(800, now);
            osc.frequency.setValueAtTime(1200, now + 0.1);
            gain.gain.setValueAtTime(0.1, now);
            gain.gain.linearRampToValueAtTime(0.01, now + 0.2);
            osc.start(now); osc.stop(now + 0.2);
        } else if (type === 'crash') {
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(100, now);
            osc.frequency.linearRampToValueAtTime(20, now + 0.5);
            gain.gain.setValueAtTime(0.5, now);
            gain.gain.linearRampToValueAtTime(0.01, now + 0.5);
            osc.start(now); osc.stop(now + 0.5);
        }
    }

    // --- GAME VARIABLES ---
    let frames = 0;
    let score = 0;
    let highscore = 0;
    let state = { current: 0, getReady: 0, game: 1, over: 2 };
    
    // Anpassen an Bildschirmgröße
    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    // --- OBJEKTE ---
    const bg = {
        draw: function() {
            // Himmel Verlauf
            let gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, "#000046");
            gradient.addColorStop(1, "#1CB5E0");
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Mond
            ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
            ctx.beginPath();
            ctx.arc(canvas.width - 50, 50, 30, 0, Math.PI*2);
            ctx.fill();
        }
    }

    const bird = {
        x: 50,
        y: 150,
        radius: 25,
        velocity: 0,
        gravity: 0.25,
        jump: 4.6,
        rotation: 0,
        
        draw: function() {
            ctx.save();
            ctx.translate(this.x, this.y);
            // Rotation basierend auf Geschwindigkeit
            this.rotation = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, (this.velocity * 0.1)));
            ctx.rotate(this.rotation);

            if (img.complete && img.naturalHeight !== 0) {
                // Bild Kreis-Maske
                ctx.beginPath();
                ctx.arc(0, 0, this.radius, 0, Math.PI*2);
                ctx.closePath();
                ctx.clip();
                ctx.drawImage(img, -this.radius, -this.radius, this.radius*2, this.radius*2);
            } else {
                // Fallback (Gelber Kreis)
                ctx.fillStyle = "yellow";
                ctx.beginPath();
                ctx.arc(0, 0, this.radius, 0, Math.PI*2);
                ctx.fill();
            }
            ctx.restore();
            
            // Weihnachtsmütze draufmalen (optional)
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.rotation);
            ctx.fillStyle = "red";
            ctx.beginPath();
            ctx.moveTo(-10, -this.radius + 5);
            ctx.lineTo(10, -this.radius + 5);
            ctx.lineTo(0, -this.radius - 20);
            ctx.fill();
            ctx.fillStyle = "white";
            ctx.beginPath(); // Bommel
            ctx.arc(0, -this.radius - 20, 5, 0, Math.PI*2);
            ctx.fill();
            ctx.restore();
        },
        
        update: function() {
            // Physik
            this.velocity += this.gravity;
            this.y += this.velocity;

            // Bodenberührung
            if (this.y + this.radius >= canvas.height) {
                this.y = canvas.height - this.radius;
                gameOver();
            }
        },
        
        flap: function() {
            this.velocity = -this.jump;
            playSound('flap');
        }
    }

    const pipes = {
        position: [],
        w: 60,
        h: 150, // Lücke
        dx: 3, // Geschwindigkeit
        
        draw: function() {
            for(let i = 0; i < this.position.length; i++) {
                let p = this.position[i];
                let topY = p.y;
                let bottomY = p.y + this.h;
                
                // Wir malen Zuckerstangen (Rot-Weiss gestreift)
                ctx.fillStyle = "#d42426"; // Rot
                ctx.fillRect(p.x, 0, this.w, topY);
                ctx.fillRect(p.x, bottomY, this.w, canvas.height - bottomY);
                
                // Streifen (Weiss)
                ctx.fillStyle = "rgba(255,255,255,0.5)";
                for(let j=0; j < topY; j+=30) ctx.fillRect(p.x, j, this.w, 10);
                for(let j=bottomY; j < canvas.height; j+=30) ctx.fillRect(p.x, j, this.w, 10);
                
                // Ränder
                ctx.strokeStyle = "#fff";
                ctx.lineWidth = 2;
                ctx.strokeRect(p.x, 0, this.w, topY);
                ctx.strokeRect(p.x, bottomY, this.w, canvas.height - bottomY);
            }
        },
        
        update: function() {
            // Alle 100 Frames neue Pipe
            if (frames % 120 === 0) {
                this.position.push({
                    x: canvas.width,
                    y: Math.random() * (canvas.height - 300) + 50
                });
            }
            
            for(let i = 0; i < this.position.length; i++) {
                let p = this.position[i];
                p.x -= this.dx; // Nach links bewegen

                // Kollision
                // Ein bisschen Toleranz (Hitbox kleiner als Grafik)
                let birdLeft = bird.x - bird.radius + 5;
                let birdRight = bird.x + bird.radius - 5;
                let birdTop = bird.y - bird.radius + 5;
                let birdBottom = bird.y + bird.radius - 5;

                let pipeLeft = p.x;
                let pipeRight = p.x + this.w;
                let topPipeBottom = p.y;
                let bottomPipeTop = p.y + this.h;

                // Check X
                if (birdRight > pipeLeft && birdLeft < pipeRight) {
                    // Check Y (Getroffen oben ODER unten)
                    if (birdTop < topPipeBottom || birdBottom > bottomPipeTop) {
                        gameOver();
                    }
                }

                // Score erhöhen wenn vorbei
                if (p.x + this.w < bird.x && !p.passed) {
                    score++;
                    p.passed = true;
                    playSound('score');
                    // Schneller werden
                    if(score % 5 === 0) this.dx += 0.5;
                }

                // Entfernen wenn aus dem Bild
                if (p.x + this.w <= 0) {
                    this.position.shift();
                    i--; // Index korrigieren
                }
            }
        },
        
        reset: function() {
            this.position = [];
            this.dx = 3;
        }
    }

    // --- GAME LOOP ---
    function loop() {
        // Hintergrund
        bg.draw();
        
        if (state.current === state.getReady) {
            // Warten auf Start
            bird.y = canvas.height / 2;
            bird.draw();
        } else if (state.current === state.game) {
            pipes.update();
            pipes.draw();
            bird.update();
            bird.draw();
            frames++;
            
            // Score malen
            ctx.fillStyle = "#FFF";
            ctx.font = "40px Arial Black";
            ctx.lineWidth = 2;
            ctx.strokeStyle = "#000";
            ctx.strokeText(score, canvas.width/2 - 10, 50);
            ctx.fillText(score, canvas.width/2 - 10, 50);

        } else if (state.current === state.over) {
            pipes.draw();
            bird.draw();
        }
        
        requestAnimationFrame(loop);
    }
    
    // --- ACTIONS ---
    function action() {
        if (state.current === state.getReady) {
            state.current = state.game;
            overlay.style.display = 'none';
            bird.flap();
        } else if (state.current === state.game) {
            bird.flap();
        } else if (state.current === state.over) {
            // Reset
            state.current = state.getReady;
            pipes.reset();
            score = 0;
            bird.velocity = 0;
            frames = 0;
            title.innerText = "FLAPPY ANDREA";
            subtitle.innerText = "Tippen zum Fliegen!";
            overlay.style.display = 'flex';
        }
    }

    function gameOver() {
        if(state.current === state.over) return;
        state.current = state.over;
        playSound('crash');
        if(score > highscore) highscore = score;
        
        title.innerText = "CRASH!";
        subtitle.innerHTML = `Score: ${score}<br>Best: ${highscore}<br><br><small>Tippen für Neustart</small>`;
        overlay.style.display = 'flex';
    }

    // Inputs
    window.addEventListener("click", action);
    window.addEventListener("keydown", (e) => {
        if (e.code === "Space") action();
    });
    window.addEventListener("touchstart", (e) => {
        e.preventDefault(); // Verhindert Zoom/Scroll
        action();
    }, {passive: false});

    // Start Loop
    loop();

</script>
</body>
</html>
